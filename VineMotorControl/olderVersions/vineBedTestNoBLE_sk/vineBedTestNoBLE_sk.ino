/*
  Motor Control for Vine Bed Transfer
  Sreela Kodali kodali@stanford.edu

  modified by Godson Osele (6/4/24) to remove Bluetooth Use

  This control different groups of the brushless motors with Serial input.
*/

#include <ArduinoBLE.h>
#include <Servo.h>


#define N_ACT 8   // Number of actuators, 8 motors
#define N_CMDS 9  // number of

// /*---------------State Definitions--------------------------*/
// // States of the system
// typedef enum {
//   DEPVINE,
//   LnR,
//   TCW,
//   BASE,
//   STOP
// } States_t;

// States_t state;

// These are the range of PWM values the SPARK Max Controller understands
// See PWM Input Specs here for more details:
// https://docs.revrobotics.com/sparkmax/specifications
// The PWM signal that goes to the Spark Max is generated by a function called
// writeMicroseconds(x).
// motor.writeMicroseconds(1025) = reverse max speed
// motor.writeMicroseconds(1500) = neutral, no movement
// motor.writeMicroseconds(2000) = forwawrd max speed

typedef enum {
  MOTOR_MIN = 1025,
  MOTOR_NEUTRAL = 1500,
  MOTOR_MAX = 2000
} MOTOR_LIMITS;


// IF YOU WANT TO SEND THE SAME COMMAND TO GROUPS OF MOTORS
// I created a little structure "cmd" (short for "command") where you give it a name,
// and identify which motors you want to run with a binary array so you can run different
// groups of motors at the same time! For example, if I want to control motors 1-4 at the
// same time, I'd add the following to my allCommands[] array:
//         initializeCmd("myCommand", {1, 1, 1, 1, 0, 0, 0, 0, 0})
// Then, when I open the app and connect with the Arduino, "myCommand" will appear as an
// option where I can write/send one value that'll go to motors 1-4.

// struct cmd {
//   char* strname;
//   int* motors;
//   BLEIntCharacteristic ble;
// };

// cmd initializeCmd(char* s, int* m) {
//   BLEIntCharacteristic bleCharacteristic("2A59", BLEWrite);  // 2A59, analog output
//   BLEDescriptor des("2901", s);                              // adding user description (2901) for the characteristic
//   bleCharacteristic.addDescriptor(des);
//   bleCharacteristic.writeValue(0);
//   cmd c{ s, m, bleCharacteristic };
//   return c;
// }

//BLEService motorService("01D");  // Bluetooth® Low Energy, motorized device


// IMPORTANT!!!
// IF YOU WANT TO ADJUST THE RANGE, RESOLUTION, SPEEDS FOR THE MAPPING OF BLE-TO-MOTOR CMDS,
// ETC. BEYOND THE DEFAULT TEN PRESET VALUES, READ THIS!

// The default works simply and as follows: We have a small integer array of length 10 called
// uSCommandValues (abbreviation for // microsecondCommandValues) that has 10 distinct motor
// commands within the SparkMax's valid range between 1000 and 2000 (https://docs.revrobotics.com/sparkmax/specifications),
// as shown on line 90.
// The BLE commands are the index for this array. So for example, if someone sends
// a "1" command via their phone to the motors, the motors would receive
// writeMicroseconds(usCommandValues[1])=MOTOR_MIN.
// If you'd like different values, feel free to change the content and/or length of USCommandVValues
const int uSCommandValues[10] = { MOTOR_NEUTRAL, MOTOR_MIN, 1185, 1285, 1385, MOTOR_NEUTRAL, 1650, 1750, 1850, MOTOR_MAX };


const int neutralCMD_min = 1450;
const int neutralCMD_max = 1550;
// which motors will be on for each command

const int maxParams = 3;  // Maximum parameters that can be sent in a single command

// tcw1, tcw2, tcw3, tcw4, base1, base2, base3, base4, pressure regulator
// int motors_CMD1[N_ACT] = { 0, 0, 0, 0, 1, 1, 1, 1 };
// int motors_CMD2[N_ACT] = { 1, 1, 1, 1, 0, 0, 0, 0 };
// int motors_CMD3[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };
// int motors_CMD4[N_ACT] = { 0, 0, 0, 0, 0, 0, 0, 0 };
// int motors_CMD5[N_ACT] = { 0, 0, 0, 0, 0, 0, 0, 0 };
// int motors_CMD6[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Example: Command for single motor with duration
// int motors_CMD7[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Command for all motors with two speeds and duration
// // New command for sending different speeds to different halves and swapping
// int motors_CMD8[N_ACT] = { 1, 1, 1, 1, 1, 1, 1, 1 };  // Placeholder for the new command




// cmd allCommands[N_CMDS] = {
//   initializeCmd("allBase", motors_CMD1),
//   initializeCmd("allTCWTurn", motors_CMD2),
//   initializeCmd("allBaseTCWTurn", motors_CMD3),
//   initializeCmd("individualMotor", motors_CMD4),
//   initializeCmd("pressureReg", motors_CMD5),
//   initializeCmd("PreLoadValues", motors_CMD4),
//   initializeCmd("CommandOverTime", motors_CMD8),      // New command for motor with duration
//   initializeCmd("motorsWithTwoSpeeds", motors_CMD8),  // New command for all motors with two speeds and duration
//   initializeCmd("halfAndHalfSwap", motors_CMD8)       // New command for sending different speeds to different halves and swapping
// };
// initializeCmd("PreLoadValues_Acc", motors_CMD4)};

Servo motorArr[N_ACT];

// these pins correspond  to different motor's input
const int pins_CommandOUTArr[N_ACT] = { 2, 3, 4, 5, 6, 7, 8, 9 };


//Turn off all motors
void Estop() {
  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
  }
}


//Control all Vine Bases simultaneously
void AllVines(int speedIdx) {
  int speed = uSCommandValues[speedIdx];
  for (int i = N_ACT / 2; i < N_ACT-1; ++i) {
    motorArr[i].writeMicroseconds(speed);
  }
}

//Function deploys all vines simultaneously with unique hard coded speeds.
// Written to address initial growth of vine down and under subject
void TunedVineDep() {
  int arraysz = N_ACT / 2;
  const int BaseSpeedDep[arraysz] = { 1385, 1385, 1385, MOTOR_NEUTRAL };  // Base speeds during initial deployment
  for (int i = N_ACT / 2; i < N_ACT; ++i) {
    int k = i - (N_ACT / 2);
    motorArr[i].writeMicroseconds(BaseSpeedDep[k]);
  }
}


//Control all TCWs simultaneously
void AllTCW(int speedIdx) {
  int speed = uSCommandValues[speedIdx];
  for (int i = 0; i < N_ACT / 2; ++i) {
    motorArr[i].writeMicroseconds(speed);
  }
}


// Turn each motor individually
void runMotor(int motorIndex, int speedIdx) {
  // This function should contain the code to set the specified motor to the given speed
  // Placeholder for motor control logic
  int speed = uSCommandValues[speedIdx];
  motorArr[motorIndex].writeMicroseconds(speed);
  Serial.print("Running motor ");
  Serial.print(motorIndex);
  Serial.print(" at speed ");
  Serial.println(speed);

}

//Initiate Lift and Return Sequence
//Lifting subject from bed and putting back down with preset speeds
void LiftandReturn() {
  int arraysz = N_ACT / 2;
  // speed are chosen based on the expected ratio relationship of the rotational velocities
  // of the base and TCW per their respective radii. The "delta" from motor neutral is based
  // this ratio.
  // I.E. TCW speed = NEUTRAL + 150 -> Base speed = NEUTRAL - (150*(R_TCW/R_base))

  const int TCWSpeedLift[arraysz] = {1436, 1436, 1436, MOTOR_NEUTRAL };    // TCW speeds during lift
  const int TCWSpeedReturn[arraysz] = { 1600, 1600, 1600, MOTOR_NEUTRAL };  // TCW speeds during return
  const int BaseSpeedLift[arraysz] = { 1791, 1791, 1791, MOTOR_NEUTRAL };    // Base speeds during lift
  const int BaseSpeedReturn[arraysz] = { 1245, 1245, 1245, MOTOR_NEUTRAL};  // Base speeds during return
  int duration = 5;                                                 // duration of lift and return respectively

  // Set first half of motors to speed1 and second half to speed2
  for (int i = 0; i < N_ACT / 2; ++i) {
    motorArr[i].writeMicroseconds(TCWSpeedLift[i]);
  }
  for (int i = N_ACT / 2; i < N_ACT; ++i) {
    int k = i - (N_ACT / 2);
    motorArr[i].writeMicroseconds(BaseSpeedLift[k]);
  }
  delay(duration * 1000);  // Convert duration of lift to seconds

  // Set all motors back to neutral
  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
  }

  delay(3000);  // 3 second delay between commands

  // Reverse the direction: Set first half to speed2 and second half to speed1
  for (int i = 0; i < N_ACT / 2; ++i) {
    motorArr[i].writeMicroseconds(TCWSpeedReturn[i]);
  }
  for (int i = N_ACT / 2; i < N_ACT; ++i) {
    int k = i - (N_ACT / 2);
    motorArr[i].writeMicroseconds(BaseSpeedReturn[k]);
  }

  delay(duration * 1000);  // Convert duration of return to seconds

  // Set all motors back to neutral
  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
  }
}


void executeCommand(char command, int* numbers, int count) {
  // Placeholder for command execution logic
  digitalWrite(LED_BUILTIN, HIGH);  // turn on LED value for commmand being sent
  Serial.print("Executing command ");
  Serial.println(command);

  if (numbers != nullptr) {

    if (command == 'K') {
      int mtrIdx = numbers[0];
      int speedIdx = numbers[1];
      for (int i = 0; i < count; i++) {
        Serial.print("Using parameter ");
        Serial.println(numbers[i]);
      }
      runMotor(mtrIdx, speedIdx);
    } else if (command == 'V') {
      int speedIdx = numbers[0];
      for (int i = 0; i < count; i++) {
        Serial.print("Using parameter ");
        Serial.println(numbers[i]);
      }
      AllVines(speedIdx);
    } else if (command == 'T') {
      int speedIdx = numbers[0];
      for (int i = 0; i < count; i++) {
        Serial.print("Using parameter ");
        Serial.println(numbers[i]);
      }
        AllTCW(speedIdx);
      } else  {
        for (int i = 0; i < N_ACT; ++i) {
          motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
        }
      }
      
    }
    //Could put this for loop in every if else statement for sanity check
    // for (int i = 0; i < count; i++) {
    //   Serial.print("Using parameter ");
    //   Serial.println(numbers[i]);
    //   // Example: perform some action based on the command and parameter
    //   // In a real application, you would replace this with actual logic
    // }
  else {
    // Handle the command without parameters
    Serial.println("Executing command without parameters.");
    // In a real application, you would replace this with actual logic
    if (command == 'E') {
      Estop();
    } else if (command == 'D') {
      TunedVineDep();
    } else if (command == 'L') {
      LiftandReturn();
    } else {
      for (int i = 0; i < N_ACT; ++i) {
        motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
      }
    }
  }
}

void setup() {
  // Initialize serial communication at 9600 bits per second:
  Serial.begin(9600);
  Serial.flush(); // 
  // Wait for the serial communication to be ready
  while (!Serial) {
    ;  // Wait for the serial port to connect. Needed for native USB port only
  }

  // begin initialization
  // if (!BLE.begin()) {
  //   while (1)
  //     ;  // Serial.println("starting Bluetooth® Low Energy module failed!");
  // }

  // set advertised local name and service UUID:
  // BLE.setLocalName("Nano 33 BLE");
  // BLE.setAdvertisedService(motorService);

  // set LED pin to output mode
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(LEDR, OUTPUT);
  pinMode(LEDG, OUTPUT);
  pinMode(LEDB, OUTPUT);

  digitalWrite(LEDR, HIGH);  // off
  digitalWrite(LEDG, HIGH);  // off
  digitalWrite(LEDB, HIGH);  // off

  for (int i = 0; i < N_ACT; ++i) {
    motorArr[i].attach(pins_CommandOUTArr[i]);  // connect each motor to PWM output
    // if (i == (N_ACT - 1)) {
    //   motorArr[i].writeMicroseconds(PRESSURE_NEUTRAL);
    // } else {
    motorArr[i].writeMicroseconds(MOTOR_NEUTRAL);
    //}
  }

  // for (int i = 0; i < N_CMDS; ++i) {
  //   motorService.addCharacteristic(((allCommands[i]).ble));  // add the characteristic to the service
  // }

  // BLE.addService(motorService);  // add service
  // BLE.advertise();               // start advertising

  //    Serial.println("Initialized.");
}


void loop() {

  // listen for Bluetooth® Low Energy peripherals to connect:
  // BLEDevice central = BLE.central();

  // if a central is connected to peripheral:
  if (Serial.available() > 0) {

    // while the central is still connected to peripheral:
    // while (central.connected()) {
    // if the remote device wrote to the characteristic,
    // use the value to control the LED:
    // Read the input string from serial
    String inputString = Serial.readStringUntil('\n');

    // Remove any whitespace characters
    inputString.trim();

    // Extract the command identifier (first character)
    char command = inputString.charAt(0);

    // Print the command identifier
    Serial.print("Command: ");
    Serial.println(command);

    // Extract the parameters (integers) from the rest of the input
    // Array to store parameters
    int numbers[maxParams];
    int count = 0;

    // Extract parameters
    int len = inputString.length();
    int startIdx = 1;  // Start after the command character

    for (int i = 1; i <= len; i++) {
      if (i == len || inputString.charAt(i) == ' ') {
        if (i > startIdx) {
          String paramStr = inputString.substring(startIdx, i);
          int param = paramStr.toInt();
          if (count < maxParams) {
            numbers[count++] = param;
          } else {
            Serial.println("Too many parameters, ignoring extra values.");
            break;
          }
        }
        startIdx = i + 1;  // Update start index for next parameter
      }
    }

    int numlength = sizeof(numbers) / sizeof(numbers[0]); // Calculate length of numbers array 

    if (count > 0) {
      //Print the parameters
      // for (int i = 0; i < count; i++) {
      //   Serial.print("Parameter ");
      //   Serial.print(i);
      //   Serial.print(": ");
      //   Serial.println(numbers[i]);
      // }


      // use command and numbers array for further processing
      // For example, run the specified motor at the given speed
      executeCommand(command, numbers, count);
    } else {
      // No parameters provided
      //Serial.println("No parameters provided.");

      // handle the case where only the command is given
      executeCommand(command, nullptr, 0);
    }

    // Prompt for the next input
    Serial.println("Enter a command followed by integers (e.g., M 10 20 30) or just a command:");
    delay(500);
    digitalWrite(LED_BUILTIN, LOW);  // turn off LED
  }
}

